{"ast":null,"code":"import { factory } from '../../utils/factory.js';\nimport { format } from '../../utils/string.js';\nimport { createComplexEigs } from './eigs/complexEigs.js';\nimport { createRealSymmetric } from './eigs/realSymetric.js';\nimport { typeOf, isNumber, isBigNumber, isComplex, isFraction } from '../../utils/is.js';\nvar name = 'eigs'; // The absolute state of math.js's dependency system:\n\nvar dependencies = ['config', 'typed', 'matrix', 'addScalar', 'equal', 'subtract', 'abs', 'atan', 'cos', 'sin', 'multiplyScalar', 'divideScalar', 'inv', 'bignumber', 'multiply', 'add', 'larger', 'column', 'flatten', 'number', 'complex', 'sqrt', 'diag', 'qr', 'usolve', 'usolveAll', 'im', 're', 'smaller', 'matrixFromColumns', 'dot'];\nexport var createEigs = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var config = _ref.config,\n      typed = _ref.typed,\n      matrix = _ref.matrix,\n      addScalar = _ref.addScalar,\n      subtract = _ref.subtract,\n      equal = _ref.equal,\n      abs = _ref.abs,\n      atan = _ref.atan,\n      cos = _ref.cos,\n      sin = _ref.sin,\n      multiplyScalar = _ref.multiplyScalar,\n      divideScalar = _ref.divideScalar,\n      inv = _ref.inv,\n      bignumber = _ref.bignumber,\n      multiply = _ref.multiply,\n      add = _ref.add,\n      larger = _ref.larger,\n      column = _ref.column,\n      flatten = _ref.flatten,\n      number = _ref.number,\n      complex = _ref.complex,\n      sqrt = _ref.sqrt,\n      diag = _ref.diag,\n      qr = _ref.qr,\n      usolve = _ref.usolve,\n      usolveAll = _ref.usolveAll,\n      im = _ref.im,\n      re = _ref.re,\n      smaller = _ref.smaller,\n      matrixFromColumns = _ref.matrixFromColumns,\n      dot = _ref.dot;\n  var doRealSymetric = createRealSymmetric({\n    config: config,\n    addScalar: addScalar,\n    subtract: subtract,\n    column: column,\n    flatten: flatten,\n    equal: equal,\n    abs: abs,\n    atan: atan,\n    cos: cos,\n    sin: sin,\n    multiplyScalar: multiplyScalar,\n    inv: inv,\n    bignumber: bignumber,\n    complex: complex,\n    multiply: multiply,\n    add: add\n  });\n  var doComplexEigs = createComplexEigs({\n    config: config,\n    addScalar: addScalar,\n    subtract: subtract,\n    multiply: multiply,\n    multiplyScalar: multiplyScalar,\n    flatten: flatten,\n    divideScalar: divideScalar,\n    sqrt: sqrt,\n    abs: abs,\n    bignumber: bignumber,\n    diag: diag,\n    qr: qr,\n    inv: inv,\n    usolve: usolve,\n    usolveAll: usolveAll,\n    equal: equal,\n    complex: complex,\n    larger: larger,\n    smaller: smaller,\n    matrixFromColumns: matrixFromColumns,\n    dot: dot\n  });\n  /**\n   * Compute eigenvalues and eigenvectors of a matrix. The eigenvalues are sorted by their absolute value, ascending.\n   * An eigenvalue with multiplicity k will be listed k times. The eigenvectors are returned as columns of a matrix –\n   * the eigenvector that belongs to the j-th eigenvalue in the list (eg. `values[j]`) is the j-th column (eg. `column(vectors, j)`).\n   * If the algorithm fails to converge, it will throw an error – in that case, however, you may still find useful information\n   * in `err.values` and `err.vectors`.\n   *\n   * Syntax:\n   *\n   *     math.eigs(x, [prec])\n   *\n   * Examples:\n   *\n   *     const { eigs, multiply, column, transpose } = math\n   *     const H = [[5, 2.3], [2.3, 1]]\n   *     const ans = eigs(H) // returns {values: [E1,E2...sorted], vectors: [v1,v2.... corresponding vectors as columns]}\n   *     const E = ans.values\n   *     const U = ans.vectors\n   *     multiply(H, column(U, 0)) // returns multiply(E[0], column(U, 0))\n   *     const UTxHxU = multiply(transpose(U), H, U) // diagonalizes H\n   *     E[0] == UTxHxU[0][0]  // returns true\n   *\n   * See also:\n   *\n   *     inv\n   *\n   * @param {Array | Matrix} x  Matrix to be diagonalized\n   *\n   * @param {number | BigNumber} [prec] Precision, default value: 1e-15\n   * @return {{values: Array|Matrix, vectors: Array|Matrix}} Object containing an array of eigenvalues and a matrix with eigenvectors as columns.\n   *\n   */\n\n  return typed('eigs', {\n    Array: function Array(x) {\n      var mat = matrix(x);\n      return computeValuesAndVectors(mat);\n    },\n    'Array, number|BigNumber': function ArrayNumberBigNumber(x, prec) {\n      var mat = matrix(x);\n      return computeValuesAndVectors(mat, prec);\n    },\n    Matrix: function Matrix(mat) {\n      var _computeValuesAndVect = computeValuesAndVectors(mat),\n          values = _computeValuesAndVect.values,\n          vectors = _computeValuesAndVect.vectors;\n\n      return {\n        values: matrix(values),\n        vectors: matrix(vectors)\n      };\n    },\n    'Matrix, number|BigNumber': function MatrixNumberBigNumber(mat, prec) {\n      var _computeValuesAndVect2 = computeValuesAndVectors(mat, prec),\n          values = _computeValuesAndVect2.values,\n          vectors = _computeValuesAndVect2.vectors;\n\n      return {\n        values: matrix(values),\n        vectors: matrix(vectors)\n      };\n    }\n  });\n\n  function computeValuesAndVectors(mat, prec) {\n    if (prec === undefined) {\n      prec = config.epsilon;\n    }\n\n    var size = mat.size();\n\n    if (size.length !== 2 || size[0] !== size[1]) {\n      throw new RangeError('Matrix must be square (size: ' + format(size) + ')');\n    }\n\n    var arr = mat.toArray();\n    var N = size[0];\n\n    if (isReal(arr, N, prec)) {\n      coerceReal(arr, N);\n\n      if (isSymmetric(arr, N, prec)) {\n        var _type = coerceTypes(mat, arr, N);\n\n        return doRealSymetric(arr, N, prec, _type);\n      }\n    }\n\n    var type = coerceTypes(mat, arr, N);\n    return doComplexEigs(arr, N, prec, type);\n  }\n  /** @return {boolean} */\n\n\n  function isSymmetric(arr, N, prec) {\n    for (var i = 0; i < N; i++) {\n      for (var j = i; j < N; j++) {\n        // TODO proper comparison of bignum and frac\n        if (larger(bignumber(abs(subtract(arr[i][j], arr[j][i]))), prec)) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n  /** @return {boolean} */\n\n\n  function isReal(arr, N, prec) {\n    for (var i = 0; i < N; i++) {\n      for (var j = 0; j < N; j++) {\n        // TODO proper comparison of bignum and frac\n        if (larger(bignumber(abs(im(arr[i][j]))), prec)) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  function coerceReal(arr, N) {\n    for (var i = 0; i < N; i++) {\n      for (var j = 0; j < N; j++) {\n        arr[i][j] = re(arr[i][j]);\n      }\n    }\n  }\n  /** @return {'number' | 'BigNumber' | 'Complex'} */\n\n\n  function coerceTypes(mat, arr, N) {\n    /** @type {string} */\n    var type = mat.datatype();\n\n    if (type === 'number' || type === 'BigNumber' || type === 'Complex') {\n      return type;\n    }\n\n    var hasNumber = false;\n    var hasBig = false;\n    var hasComplex = false;\n\n    for (var i = 0; i < N; i++) {\n      for (var j = 0; j < N; j++) {\n        var el = arr[i][j];\n\n        if (isNumber(el) || isFraction(el)) {\n          hasNumber = true;\n        } else if (isBigNumber(el)) {\n          hasBig = true;\n        } else if (isComplex(el)) {\n          hasComplex = true;\n        } else {\n          throw TypeError('Unsupported type in Matrix: ' + typeOf(el));\n        }\n      }\n    }\n\n    if (hasBig && hasComplex) {\n      console.warn('Complex BigNumbers not supported, this operation will lose precission.');\n    }\n\n    if (hasComplex) {\n      for (var _i = 0; _i < N; _i++) {\n        for (var _j = 0; _j < N; _j++) {\n          arr[_i][_j] = complex(arr[_i][_j]);\n        }\n      }\n\n      return 'Complex';\n    }\n\n    if (hasBig) {\n      for (var _i2 = 0; _i2 < N; _i2++) {\n        for (var _j2 = 0; _j2 < N; _j2++) {\n          arr[_i2][_j2] = bignumber(arr[_i2][_j2]);\n        }\n      }\n\n      return 'BigNumber';\n    }\n\n    if (hasNumber) {\n      for (var _i3 = 0; _i3 < N; _i3++) {\n        for (var _j3 = 0; _j3 < N; _j3++) {\n          arr[_i3][_j3] = number(arr[_i3][_j3]);\n        }\n      }\n\n      return 'number';\n    } else {\n      throw TypeError('Matrix contains unsupported types only.');\n    }\n  }\n});","map":{"version":3,"sources":["/Users/aw/olympus-labs/client/node_modules/mathjs/lib/esm/function/matrix/eigs.js"],"names":["factory","format","createComplexEigs","createRealSymmetric","typeOf","isNumber","isBigNumber","isComplex","isFraction","name","dependencies","createEigs","_ref","config","typed","matrix","addScalar","subtract","equal","abs","atan","cos","sin","multiplyScalar","divideScalar","inv","bignumber","multiply","add","larger","column","flatten","number","complex","sqrt","diag","qr","usolve","usolveAll","im","re","smaller","matrixFromColumns","dot","doRealSymetric","doComplexEigs","Array","x","mat","computeValuesAndVectors","ArrayNumberBigNumber","prec","Matrix","values","vectors","MatrixNumberBigNumber","undefined","epsilon","size","length","RangeError","arr","toArray","N","isReal","coerceReal","isSymmetric","_type","coerceTypes","type","i","j","datatype","hasNumber","hasBig","hasComplex","el","TypeError","console","warn","_i","_j","_i2","_j2","_i3","_j3"],"mappings":"AAAA,SAASA,OAAT,QAAwB,wBAAxB;AACA,SAASC,MAAT,QAAuB,uBAAvB;AACA,SAASC,iBAAT,QAAkC,uBAAlC;AACA,SAASC,mBAAT,QAAoC,wBAApC;AACA,SAASC,MAAT,EAAiBC,QAAjB,EAA2BC,WAA3B,EAAwCC,SAAxC,EAAmDC,UAAnD,QAAqE,mBAArE;AACA,IAAIC,IAAI,GAAG,MAAX,C,CAAmB;;AAEnB,IAAIC,YAAY,GAAG,CAAC,QAAD,EAAW,OAAX,EAAoB,QAApB,EAA8B,WAA9B,EAA2C,OAA3C,EAAoD,UAApD,EAAgE,KAAhE,EAAuE,MAAvE,EAA+E,KAA/E,EAAsF,KAAtF,EAA6F,gBAA7F,EAA+G,cAA/G,EAA+H,KAA/H,EAAsI,WAAtI,EAAmJ,UAAnJ,EAA+J,KAA/J,EAAsK,QAAtK,EAAgL,QAAhL,EAA0L,SAA1L,EAAqM,QAArM,EAA+M,SAA/M,EAA0N,MAA1N,EAAkO,MAAlO,EAA0O,IAA1O,EAAgP,QAAhP,EAA0P,WAA1P,EAAuQ,IAAvQ,EAA6Q,IAA7Q,EAAmR,SAAnR,EAA8R,mBAA9R,EAAmT,KAAnT,CAAnB;AACA,OAAO,IAAIC,UAAU,GAAG,eAAeX,OAAO,CAACS,IAAD,EAAOC,YAAP,EAAqB,UAAAE,IAAI,EAAI;AACzE,MACEC,MADF,GAgCID,IAhCJ,CACEC,MADF;AAAA,MAEEC,KAFF,GAgCIF,IAhCJ,CAEEE,KAFF;AAAA,MAGEC,MAHF,GAgCIH,IAhCJ,CAGEG,MAHF;AAAA,MAIEC,SAJF,GAgCIJ,IAhCJ,CAIEI,SAJF;AAAA,MAKEC,QALF,GAgCIL,IAhCJ,CAKEK,QALF;AAAA,MAMEC,KANF,GAgCIN,IAhCJ,CAMEM,KANF;AAAA,MAOEC,GAPF,GAgCIP,IAhCJ,CAOEO,GAPF;AAAA,MAQEC,IARF,GAgCIR,IAhCJ,CAQEQ,IARF;AAAA,MASEC,GATF,GAgCIT,IAhCJ,CASES,GATF;AAAA,MAUEC,GAVF,GAgCIV,IAhCJ,CAUEU,GAVF;AAAA,MAWEC,cAXF,GAgCIX,IAhCJ,CAWEW,cAXF;AAAA,MAYEC,YAZF,GAgCIZ,IAhCJ,CAYEY,YAZF;AAAA,MAaEC,GAbF,GAgCIb,IAhCJ,CAaEa,GAbF;AAAA,MAcEC,SAdF,GAgCId,IAhCJ,CAcEc,SAdF;AAAA,MAeEC,QAfF,GAgCIf,IAhCJ,CAeEe,QAfF;AAAA,MAgBEC,GAhBF,GAgCIhB,IAhCJ,CAgBEgB,GAhBF;AAAA,MAiBEC,MAjBF,GAgCIjB,IAhCJ,CAiBEiB,MAjBF;AAAA,MAkBEC,MAlBF,GAgCIlB,IAhCJ,CAkBEkB,MAlBF;AAAA,MAmBEC,OAnBF,GAgCInB,IAhCJ,CAmBEmB,OAnBF;AAAA,MAoBEC,MApBF,GAgCIpB,IAhCJ,CAoBEoB,MApBF;AAAA,MAqBEC,OArBF,GAgCIrB,IAhCJ,CAqBEqB,OArBF;AAAA,MAsBEC,IAtBF,GAgCItB,IAhCJ,CAsBEsB,IAtBF;AAAA,MAuBEC,IAvBF,GAgCIvB,IAhCJ,CAuBEuB,IAvBF;AAAA,MAwBEC,EAxBF,GAgCIxB,IAhCJ,CAwBEwB,EAxBF;AAAA,MAyBEC,MAzBF,GAgCIzB,IAhCJ,CAyBEyB,MAzBF;AAAA,MA0BEC,SA1BF,GAgCI1B,IAhCJ,CA0BE0B,SA1BF;AAAA,MA2BEC,EA3BF,GAgCI3B,IAhCJ,CA2BE2B,EA3BF;AAAA,MA4BEC,EA5BF,GAgCI5B,IAhCJ,CA4BE4B,EA5BF;AAAA,MA6BEC,OA7BF,GAgCI7B,IAhCJ,CA6BE6B,OA7BF;AAAA,MA8BEC,iBA9BF,GAgCI9B,IAhCJ,CA8BE8B,iBA9BF;AAAA,MA+BEC,GA/BF,GAgCI/B,IAhCJ,CA+BE+B,GA/BF;AAiCA,MAAIC,cAAc,GAAGzC,mBAAmB,CAAC;AACvCU,IAAAA,MAAM,EAANA,MADuC;AAEvCG,IAAAA,SAAS,EAATA,SAFuC;AAGvCC,IAAAA,QAAQ,EAARA,QAHuC;AAIvCa,IAAAA,MAAM,EAANA,MAJuC;AAKvCC,IAAAA,OAAO,EAAPA,OALuC;AAMvCb,IAAAA,KAAK,EAALA,KANuC;AAOvCC,IAAAA,GAAG,EAAHA,GAPuC;AAQvCC,IAAAA,IAAI,EAAJA,IARuC;AASvCC,IAAAA,GAAG,EAAHA,GATuC;AAUvCC,IAAAA,GAAG,EAAHA,GAVuC;AAWvCC,IAAAA,cAAc,EAAdA,cAXuC;AAYvCE,IAAAA,GAAG,EAAHA,GAZuC;AAavCC,IAAAA,SAAS,EAATA,SAbuC;AAcvCO,IAAAA,OAAO,EAAPA,OAduC;AAevCN,IAAAA,QAAQ,EAARA,QAfuC;AAgBvCC,IAAAA,GAAG,EAAHA;AAhBuC,GAAD,CAAxC;AAkBA,MAAIiB,aAAa,GAAG3C,iBAAiB,CAAC;AACpCW,IAAAA,MAAM,EAANA,MADoC;AAEpCG,IAAAA,SAAS,EAATA,SAFoC;AAGpCC,IAAAA,QAAQ,EAARA,QAHoC;AAIpCU,IAAAA,QAAQ,EAARA,QAJoC;AAKpCJ,IAAAA,cAAc,EAAdA,cALoC;AAMpCQ,IAAAA,OAAO,EAAPA,OANoC;AAOpCP,IAAAA,YAAY,EAAZA,YAPoC;AAQpCU,IAAAA,IAAI,EAAJA,IARoC;AASpCf,IAAAA,GAAG,EAAHA,GAToC;AAUpCO,IAAAA,SAAS,EAATA,SAVoC;AAWpCS,IAAAA,IAAI,EAAJA,IAXoC;AAYpCC,IAAAA,EAAE,EAAFA,EAZoC;AAapCX,IAAAA,GAAG,EAAHA,GAboC;AAcpCY,IAAAA,MAAM,EAANA,MAdoC;AAepCC,IAAAA,SAAS,EAATA,SAfoC;AAgBpCpB,IAAAA,KAAK,EAALA,KAhBoC;AAiBpCe,IAAAA,OAAO,EAAPA,OAjBoC;AAkBpCJ,IAAAA,MAAM,EAANA,MAlBoC;AAmBpCY,IAAAA,OAAO,EAAPA,OAnBoC;AAoBpCC,IAAAA,iBAAiB,EAAjBA,iBApBoC;AAqBpCC,IAAAA,GAAG,EAAHA;AArBoC,GAAD,CAArC;AAuBA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEE,SAAO7B,KAAK,CAAC,MAAD,EAAS;AACnBgC,IAAAA,KAAK,EAAE,SAASA,KAAT,CAAeC,CAAf,EAAkB;AACvB,UAAIC,GAAG,GAAGjC,MAAM,CAACgC,CAAD,CAAhB;AACA,aAAOE,uBAAuB,CAACD,GAAD,CAA9B;AACD,KAJkB;AAKnB,+BAA2B,SAASE,oBAAT,CAA8BH,CAA9B,EAAiCI,IAAjC,EAAuC;AAChE,UAAIH,GAAG,GAAGjC,MAAM,CAACgC,CAAD,CAAhB;AACA,aAAOE,uBAAuB,CAACD,GAAD,EAAMG,IAAN,CAA9B;AACD,KARkB;AASnBC,IAAAA,MAAM,EAAE,SAASA,MAAT,CAAgBJ,GAAhB,EAAqB;AAC3B,kCAGIC,uBAAuB,CAACD,GAAD,CAH3B;AAAA,UACEK,MADF,yBACEA,MADF;AAAA,UAEEC,OAFF,yBAEEA,OAFF;;AAIA,aAAO;AACLD,QAAAA,MAAM,EAAEtC,MAAM,CAACsC,MAAD,CADT;AAELC,QAAAA,OAAO,EAAEvC,MAAM,CAACuC,OAAD;AAFV,OAAP;AAID,KAlBkB;AAmBnB,gCAA4B,SAASC,qBAAT,CAA+BP,GAA/B,EAAoCG,IAApC,EAA0C;AACpE,mCAGIF,uBAAuB,CAACD,GAAD,EAAMG,IAAN,CAH3B;AAAA,UACEE,MADF,0BACEA,MADF;AAAA,UAEEC,OAFF,0BAEEA,OAFF;;AAIA,aAAO;AACLD,QAAAA,MAAM,EAAEtC,MAAM,CAACsC,MAAD,CADT;AAELC,QAAAA,OAAO,EAAEvC,MAAM,CAACuC,OAAD;AAFV,OAAP;AAID;AA5BkB,GAAT,CAAZ;;AA+BA,WAASL,uBAAT,CAAiCD,GAAjC,EAAsCG,IAAtC,EAA4C;AAC1C,QAAIA,IAAI,KAAKK,SAAb,EAAwB;AACtBL,MAAAA,IAAI,GAAGtC,MAAM,CAAC4C,OAAd;AACD;;AAED,QAAIC,IAAI,GAAGV,GAAG,CAACU,IAAJ,EAAX;;AAEA,QAAIA,IAAI,CAACC,MAAL,KAAgB,CAAhB,IAAqBD,IAAI,CAAC,CAAD,CAAJ,KAAYA,IAAI,CAAC,CAAD,CAAzC,EAA8C;AAC5C,YAAM,IAAIE,UAAJ,CAAe,kCAAkC3D,MAAM,CAACyD,IAAD,CAAxC,GAAiD,GAAhE,CAAN;AACD;;AAED,QAAIG,GAAG,GAAGb,GAAG,CAACc,OAAJ,EAAV;AACA,QAAIC,CAAC,GAAGL,IAAI,CAAC,CAAD,CAAZ;;AAEA,QAAIM,MAAM,CAACH,GAAD,EAAME,CAAN,EAASZ,IAAT,CAAV,EAA0B;AACxBc,MAAAA,UAAU,CAACJ,GAAD,EAAME,CAAN,CAAV;;AAEA,UAAIG,WAAW,CAACL,GAAD,EAAME,CAAN,EAASZ,IAAT,CAAf,EAA+B;AAC7B,YAAIgB,KAAK,GAAGC,WAAW,CAACpB,GAAD,EAAMa,GAAN,EAAWE,CAAX,CAAvB;;AAEA,eAAOnB,cAAc,CAACiB,GAAD,EAAME,CAAN,EAASZ,IAAT,EAAegB,KAAf,CAArB;AACD;AACF;;AAED,QAAIE,IAAI,GAAGD,WAAW,CAACpB,GAAD,EAAMa,GAAN,EAAWE,CAAX,CAAtB;AACA,WAAOlB,aAAa,CAACgB,GAAD,EAAME,CAAN,EAASZ,IAAT,EAAekB,IAAf,CAApB;AACD;AACD;;;AAGA,WAASH,WAAT,CAAqBL,GAArB,EAA0BE,CAA1B,EAA6BZ,IAA7B,EAAmC;AACjC,SAAK,IAAImB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGP,CAApB,EAAuBO,CAAC,EAAxB,EAA4B;AAC1B,WAAK,IAAIC,CAAC,GAAGD,CAAb,EAAgBC,CAAC,GAAGR,CAApB,EAAuBQ,CAAC,EAAxB,EAA4B;AAC1B;AACA,YAAI1C,MAAM,CAACH,SAAS,CAACP,GAAG,CAACF,QAAQ,CAAC4C,GAAG,CAACS,CAAD,CAAH,CAAOC,CAAP,CAAD,EAAYV,GAAG,CAACU,CAAD,CAAH,CAAOD,CAAP,CAAZ,CAAT,CAAJ,CAAV,EAAiDnB,IAAjD,CAAV,EAAkE;AAChE,iBAAO,KAAP;AACD;AACF;AACF;;AAED,WAAO,IAAP;AACD;AACD;;;AAGA,WAASa,MAAT,CAAgBH,GAAhB,EAAqBE,CAArB,EAAwBZ,IAAxB,EAA8B;AAC5B,SAAK,IAAImB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGP,CAApB,EAAuBO,CAAC,EAAxB,EAA4B;AAC1B,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGR,CAApB,EAAuBQ,CAAC,EAAxB,EAA4B;AAC1B;AACA,YAAI1C,MAAM,CAACH,SAAS,CAACP,GAAG,CAACoB,EAAE,CAACsB,GAAG,CAACS,CAAD,CAAH,CAAOC,CAAP,CAAD,CAAH,CAAJ,CAAV,EAAgCpB,IAAhC,CAAV,EAAiD;AAC/C,iBAAO,KAAP;AACD;AACF;AACF;;AAED,WAAO,IAAP;AACD;;AAED,WAASc,UAAT,CAAoBJ,GAApB,EAAyBE,CAAzB,EAA4B;AAC1B,SAAK,IAAIO,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGP,CAApB,EAAuBO,CAAC,EAAxB,EAA4B;AAC1B,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGR,CAApB,EAAuBQ,CAAC,EAAxB,EAA4B;AAC1BV,QAAAA,GAAG,CAACS,CAAD,CAAH,CAAOC,CAAP,IAAY/B,EAAE,CAACqB,GAAG,CAACS,CAAD,CAAH,CAAOC,CAAP,CAAD,CAAd;AACD;AACF;AACF;AACD;;;AAGA,WAASH,WAAT,CAAqBpB,GAArB,EAA0Ba,GAA1B,EAA+BE,CAA/B,EAAkC;AAChC;AACA,QAAIM,IAAI,GAAGrB,GAAG,CAACwB,QAAJ,EAAX;;AAEA,QAAIH,IAAI,KAAK,QAAT,IAAqBA,IAAI,KAAK,WAA9B,IAA6CA,IAAI,KAAK,SAA1D,EAAqE;AACnE,aAAOA,IAAP;AACD;;AAED,QAAII,SAAS,GAAG,KAAhB;AACA,QAAIC,MAAM,GAAG,KAAb;AACA,QAAIC,UAAU,GAAG,KAAjB;;AAEA,SAAK,IAAIL,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGP,CAApB,EAAuBO,CAAC,EAAxB,EAA4B;AAC1B,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGR,CAApB,EAAuBQ,CAAC,EAAxB,EAA4B;AAC1B,YAAIK,EAAE,GAAGf,GAAG,CAACS,CAAD,CAAH,CAAOC,CAAP,CAAT;;AAEA,YAAIlE,QAAQ,CAACuE,EAAD,CAAR,IAAgBpE,UAAU,CAACoE,EAAD,CAA9B,EAAoC;AAClCH,UAAAA,SAAS,GAAG,IAAZ;AACD,SAFD,MAEO,IAAInE,WAAW,CAACsE,EAAD,CAAf,EAAqB;AAC1BF,UAAAA,MAAM,GAAG,IAAT;AACD,SAFM,MAEA,IAAInE,SAAS,CAACqE,EAAD,CAAb,EAAmB;AACxBD,UAAAA,UAAU,GAAG,IAAb;AACD,SAFM,MAEA;AACL,gBAAME,SAAS,CAAC,iCAAiCzE,MAAM,CAACwE,EAAD,CAAxC,CAAf;AACD;AACF;AACF;;AAED,QAAIF,MAAM,IAAIC,UAAd,EAA0B;AACxBG,MAAAA,OAAO,CAACC,IAAR,CAAa,wEAAb;AACD;;AAED,QAAIJ,UAAJ,EAAgB;AACd,WAAK,IAAIK,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGjB,CAAtB,EAAyBiB,EAAE,EAA3B,EAA+B;AAC7B,aAAK,IAAIC,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGlB,CAAtB,EAAyBkB,EAAE,EAA3B,EAA+B;AAC7BpB,UAAAA,GAAG,CAACmB,EAAD,CAAH,CAAQC,EAAR,IAAchD,OAAO,CAAC4B,GAAG,CAACmB,EAAD,CAAH,CAAQC,EAAR,CAAD,CAArB;AACD;AACF;;AAED,aAAO,SAAP;AACD;;AAED,QAAIP,MAAJ,EAAY;AACV,WAAK,IAAIQ,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGnB,CAAxB,EAA2BmB,GAAG,EAA9B,EAAkC;AAChC,aAAK,IAAIC,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGpB,CAAxB,EAA2BoB,GAAG,EAA9B,EAAkC;AAChCtB,UAAAA,GAAG,CAACqB,GAAD,CAAH,CAASC,GAAT,IAAgBzD,SAAS,CAACmC,GAAG,CAACqB,GAAD,CAAH,CAASC,GAAT,CAAD,CAAzB;AACD;AACF;;AAED,aAAO,WAAP;AACD;;AAED,QAAIV,SAAJ,EAAe;AACb,WAAK,IAAIW,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGrB,CAAxB,EAA2BqB,GAAG,EAA9B,EAAkC;AAChC,aAAK,IAAIC,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGtB,CAAxB,EAA2BsB,GAAG,EAA9B,EAAkC;AAChCxB,UAAAA,GAAG,CAACuB,GAAD,CAAH,CAASC,GAAT,IAAgBrD,MAAM,CAAC6B,GAAG,CAACuB,GAAD,CAAH,CAASC,GAAT,CAAD,CAAtB;AACD;AACF;;AAED,aAAO,QAAP;AACD,KARD,MAQO;AACL,YAAMR,SAAS,CAAC,yCAAD,CAAf;AACD;AACF;AACF,CA/Q6C,CAAvC","sourcesContent":["import { factory } from '../../utils/factory.js';\nimport { format } from '../../utils/string.js';\nimport { createComplexEigs } from './eigs/complexEigs.js';\nimport { createRealSymmetric } from './eigs/realSymetric.js';\nimport { typeOf, isNumber, isBigNumber, isComplex, isFraction } from '../../utils/is.js';\nvar name = 'eigs'; // The absolute state of math.js's dependency system:\n\nvar dependencies = ['config', 'typed', 'matrix', 'addScalar', 'equal', 'subtract', 'abs', 'atan', 'cos', 'sin', 'multiplyScalar', 'divideScalar', 'inv', 'bignumber', 'multiply', 'add', 'larger', 'column', 'flatten', 'number', 'complex', 'sqrt', 'diag', 'qr', 'usolve', 'usolveAll', 'im', 're', 'smaller', 'matrixFromColumns', 'dot'];\nexport var createEigs = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    config,\n    typed,\n    matrix,\n    addScalar,\n    subtract,\n    equal,\n    abs,\n    atan,\n    cos,\n    sin,\n    multiplyScalar,\n    divideScalar,\n    inv,\n    bignumber,\n    multiply,\n    add,\n    larger,\n    column,\n    flatten,\n    number,\n    complex,\n    sqrt,\n    diag,\n    qr,\n    usolve,\n    usolveAll,\n    im,\n    re,\n    smaller,\n    matrixFromColumns,\n    dot\n  } = _ref;\n  var doRealSymetric = createRealSymmetric({\n    config,\n    addScalar,\n    subtract,\n    column,\n    flatten,\n    equal,\n    abs,\n    atan,\n    cos,\n    sin,\n    multiplyScalar,\n    inv,\n    bignumber,\n    complex,\n    multiply,\n    add\n  });\n  var doComplexEigs = createComplexEigs({\n    config,\n    addScalar,\n    subtract,\n    multiply,\n    multiplyScalar,\n    flatten,\n    divideScalar,\n    sqrt,\n    abs,\n    bignumber,\n    diag,\n    qr,\n    inv,\n    usolve,\n    usolveAll,\n    equal,\n    complex,\n    larger,\n    smaller,\n    matrixFromColumns,\n    dot\n  });\n  /**\n   * Compute eigenvalues and eigenvectors of a matrix. The eigenvalues are sorted by their absolute value, ascending.\n   * An eigenvalue with multiplicity k will be listed k times. The eigenvectors are returned as columns of a matrix –\n   * the eigenvector that belongs to the j-th eigenvalue in the list (eg. `values[j]`) is the j-th column (eg. `column(vectors, j)`).\n   * If the algorithm fails to converge, it will throw an error – in that case, however, you may still find useful information\n   * in `err.values` and `err.vectors`.\n   *\n   * Syntax:\n   *\n   *     math.eigs(x, [prec])\n   *\n   * Examples:\n   *\n   *     const { eigs, multiply, column, transpose } = math\n   *     const H = [[5, 2.3], [2.3, 1]]\n   *     const ans = eigs(H) // returns {values: [E1,E2...sorted], vectors: [v1,v2.... corresponding vectors as columns]}\n   *     const E = ans.values\n   *     const U = ans.vectors\n   *     multiply(H, column(U, 0)) // returns multiply(E[0], column(U, 0))\n   *     const UTxHxU = multiply(transpose(U), H, U) // diagonalizes H\n   *     E[0] == UTxHxU[0][0]  // returns true\n   *\n   * See also:\n   *\n   *     inv\n   *\n   * @param {Array | Matrix} x  Matrix to be diagonalized\n   *\n   * @param {number | BigNumber} [prec] Precision, default value: 1e-15\n   * @return {{values: Array|Matrix, vectors: Array|Matrix}} Object containing an array of eigenvalues and a matrix with eigenvectors as columns.\n   *\n   */\n\n  return typed('eigs', {\n    Array: function Array(x) {\n      var mat = matrix(x);\n      return computeValuesAndVectors(mat);\n    },\n    'Array, number|BigNumber': function ArrayNumberBigNumber(x, prec) {\n      var mat = matrix(x);\n      return computeValuesAndVectors(mat, prec);\n    },\n    Matrix: function Matrix(mat) {\n      var {\n        values,\n        vectors\n      } = computeValuesAndVectors(mat);\n      return {\n        values: matrix(values),\n        vectors: matrix(vectors)\n      };\n    },\n    'Matrix, number|BigNumber': function MatrixNumberBigNumber(mat, prec) {\n      var {\n        values,\n        vectors\n      } = computeValuesAndVectors(mat, prec);\n      return {\n        values: matrix(values),\n        vectors: matrix(vectors)\n      };\n    }\n  });\n\n  function computeValuesAndVectors(mat, prec) {\n    if (prec === undefined) {\n      prec = config.epsilon;\n    }\n\n    var size = mat.size();\n\n    if (size.length !== 2 || size[0] !== size[1]) {\n      throw new RangeError('Matrix must be square (size: ' + format(size) + ')');\n    }\n\n    var arr = mat.toArray();\n    var N = size[0];\n\n    if (isReal(arr, N, prec)) {\n      coerceReal(arr, N);\n\n      if (isSymmetric(arr, N, prec)) {\n        var _type = coerceTypes(mat, arr, N);\n\n        return doRealSymetric(arr, N, prec, _type);\n      }\n    }\n\n    var type = coerceTypes(mat, arr, N);\n    return doComplexEigs(arr, N, prec, type);\n  }\n  /** @return {boolean} */\n\n\n  function isSymmetric(arr, N, prec) {\n    for (var i = 0; i < N; i++) {\n      for (var j = i; j < N; j++) {\n        // TODO proper comparison of bignum and frac\n        if (larger(bignumber(abs(subtract(arr[i][j], arr[j][i]))), prec)) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n  /** @return {boolean} */\n\n\n  function isReal(arr, N, prec) {\n    for (var i = 0; i < N; i++) {\n      for (var j = 0; j < N; j++) {\n        // TODO proper comparison of bignum and frac\n        if (larger(bignumber(abs(im(arr[i][j]))), prec)) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  function coerceReal(arr, N) {\n    for (var i = 0; i < N; i++) {\n      for (var j = 0; j < N; j++) {\n        arr[i][j] = re(arr[i][j]);\n      }\n    }\n  }\n  /** @return {'number' | 'BigNumber' | 'Complex'} */\n\n\n  function coerceTypes(mat, arr, N) {\n    /** @type {string} */\n    var type = mat.datatype();\n\n    if (type === 'number' || type === 'BigNumber' || type === 'Complex') {\n      return type;\n    }\n\n    var hasNumber = false;\n    var hasBig = false;\n    var hasComplex = false;\n\n    for (var i = 0; i < N; i++) {\n      for (var j = 0; j < N; j++) {\n        var el = arr[i][j];\n\n        if (isNumber(el) || isFraction(el)) {\n          hasNumber = true;\n        } else if (isBigNumber(el)) {\n          hasBig = true;\n        } else if (isComplex(el)) {\n          hasComplex = true;\n        } else {\n          throw TypeError('Unsupported type in Matrix: ' + typeOf(el));\n        }\n      }\n    }\n\n    if (hasBig && hasComplex) {\n      console.warn('Complex BigNumbers not supported, this operation will lose precission.');\n    }\n\n    if (hasComplex) {\n      for (var _i = 0; _i < N; _i++) {\n        for (var _j = 0; _j < N; _j++) {\n          arr[_i][_j] = complex(arr[_i][_j]);\n        }\n      }\n\n      return 'Complex';\n    }\n\n    if (hasBig) {\n      for (var _i2 = 0; _i2 < N; _i2++) {\n        for (var _j2 = 0; _j2 < N; _j2++) {\n          arr[_i2][_j2] = bignumber(arr[_i2][_j2]);\n        }\n      }\n\n      return 'BigNumber';\n    }\n\n    if (hasNumber) {\n      for (var _i3 = 0; _i3 < N; _i3++) {\n        for (var _j3 = 0; _j3 < N; _j3++) {\n          arr[_i3][_j3] = number(arr[_i3][_j3]);\n        }\n      }\n\n      return 'number';\n    } else {\n      throw TypeError('Matrix contains unsupported types only.');\n    }\n  }\n});"]},"metadata":{},"sourceType":"module"}