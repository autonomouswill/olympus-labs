{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/aw/olympus-labs/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"/Users/aw/olympus-labs/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/aw/olympus-labs/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { setSafeProperty, hasSafeProperty, getSafeProperty } from './customs.js';\nimport { isObject } from './is.js';\n/**\n * A map facade on a bare object.\n *\n * The small number of methods needed to implement a scope,\n * forwarding on to the SafeProperty functions. Over time, the codebase\n * will stop using this method, as all objects will be Maps, rather than\n * more security prone objects.\n */\n\nexport var ObjectWrappingMap = /*#__PURE__*/function () {\n  function ObjectWrappingMap(object) {\n    _classCallCheck(this, ObjectWrappingMap);\n\n    this.wrappedObject = object;\n  }\n\n  _createClass(ObjectWrappingMap, [{\n    key: \"keys\",\n    value: function keys() {\n      return Object.keys(this.wrappedObject);\n    }\n  }, {\n    key: \"get\",\n    value: function get(key) {\n      return getSafeProperty(this.wrappedObject, key);\n    }\n  }, {\n    key: \"set\",\n    value: function set(key, value) {\n      setSafeProperty(this.wrappedObject, key, value);\n      return this;\n    }\n  }, {\n    key: \"has\",\n    value: function has(key) {\n      return hasSafeProperty(this.wrappedObject, key);\n    }\n  }]);\n\n  return ObjectWrappingMap;\n}();\n/**\n * Creates an empty map, or whatever your platform's polyfill is.\n *\n * @returns an empty Map or Map like object.\n */\n\nexport function createEmptyMap() {\n  return new Map();\n}\n/**\n * Creates a Map from the given object.\n *\n * @param { Map | { [key: string]: unknown } | undefined } mapOrObject\n * @returns\n */\n\nexport function createMap(mapOrObject) {\n  if (!mapOrObject) {\n    return createEmptyMap();\n  }\n\n  if (isMap(mapOrObject)) {\n    return mapOrObject;\n  }\n\n  if (isObject(mapOrObject)) {\n    return new ObjectWrappingMap(mapOrObject);\n  }\n\n  throw new Error('createMap can create maps from objects or Maps');\n}\n/**\n * Unwraps a map into an object.\n *\n * @param {Map} map\n * @returns { [key: string]: unknown }\n */\n\nexport function toObject(map) {\n  if (map instanceof ObjectWrappingMap) {\n    return map.wrappedObject;\n  }\n\n  var object = {};\n\n  var _iterator = _createForOfIteratorHelper(map.keys()),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var key = _step.value;\n      var value = map.get(key);\n      setSafeProperty(object, key, value);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return object;\n}\n/**\n * Returns `true` if the passed object appears to be a Map (i.e. duck typing).\n *\n * Methods looked for are `get`, `set`, `keys` and `has`.\n *\n * @param {Map | object} object\n * @returns\n */\n\nexport function isMap(object) {\n  // We can use the fast instanceof, or a slower duck typing check.\n  // The duck typing method needs to cover enough methods to not be confused with DenseMatrix.\n  if (!object) {\n    return false;\n  }\n\n  return object instanceof Map || object instanceof ObjectWrappingMap || typeof object.set === 'function' && typeof object.get === 'function' && typeof object.keys === 'function' && typeof object.has === 'function';\n}\n/**\n * Copies the contents of key-value pairs from each `objects` in to `map`.\n *\n * Object is `objects` can be a `Map` or object.\n *\n * This is the `Map` analog to `Object.assign`.\n */\n\nexport function assign(map) {\n  for (var _len = arguments.length, objects = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    objects[_key - 1] = arguments[_key];\n  }\n\n  for (var _i = 0, _objects = objects; _i < _objects.length; _i++) {\n    var args = _objects[_i];\n\n    if (!args) {\n      continue;\n    }\n\n    if (isMap(args)) {\n      var _iterator2 = _createForOfIteratorHelper(args.keys()),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var key = _step2.value;\n          map.set(key, args.get(key));\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    } else if (isObject(args)) {\n      for (var _i2 = 0, _Object$keys = Object.keys(args); _i2 < _Object$keys.length; _i2++) {\n        var _key2 = _Object$keys[_i2];\n        map.set(_key2, args[_key2]);\n      }\n    }\n  }\n\n  return map;\n}","map":{"version":3,"sources":["/Users/aw/olympus-labs/client/node_modules/mathjs/lib/esm/utils/map.js"],"names":["setSafeProperty","hasSafeProperty","getSafeProperty","isObject","ObjectWrappingMap","object","wrappedObject","Object","keys","key","value","createEmptyMap","Map","createMap","mapOrObject","isMap","Error","toObject","map","get","set","has","assign","_len","arguments","length","objects","Array","_key","args","_key2"],"mappings":"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","sourcesContent":["import { setSafeProperty, hasSafeProperty, getSafeProperty } from './customs.js';\nimport { isObject } from './is.js';\n/**\n * A map facade on a bare object.\n *\n * The small number of methods needed to implement a scope,\n * forwarding on to the SafeProperty functions. Over time, the codebase\n * will stop using this method, as all objects will be Maps, rather than\n * more security prone objects.\n */\n\nexport class ObjectWrappingMap {\n  constructor(object) {\n    this.wrappedObject = object;\n  }\n\n  keys() {\n    return Object.keys(this.wrappedObject);\n  }\n\n  get(key) {\n    return getSafeProperty(this.wrappedObject, key);\n  }\n\n  set(key, value) {\n    setSafeProperty(this.wrappedObject, key, value);\n    return this;\n  }\n\n  has(key) {\n    return hasSafeProperty(this.wrappedObject, key);\n  }\n\n}\n/**\n * Creates an empty map, or whatever your platform's polyfill is.\n *\n * @returns an empty Map or Map like object.\n */\n\nexport function createEmptyMap() {\n  return new Map();\n}\n/**\n * Creates a Map from the given object.\n *\n * @param { Map | { [key: string]: unknown } | undefined } mapOrObject\n * @returns\n */\n\nexport function createMap(mapOrObject) {\n  if (!mapOrObject) {\n    return createEmptyMap();\n  }\n\n  if (isMap(mapOrObject)) {\n    return mapOrObject;\n  }\n\n  if (isObject(mapOrObject)) {\n    return new ObjectWrappingMap(mapOrObject);\n  }\n\n  throw new Error('createMap can create maps from objects or Maps');\n}\n/**\n * Unwraps a map into an object.\n *\n * @param {Map} map\n * @returns { [key: string]: unknown }\n */\n\nexport function toObject(map) {\n  if (map instanceof ObjectWrappingMap) {\n    return map.wrappedObject;\n  }\n\n  var object = {};\n\n  for (var key of map.keys()) {\n    var value = map.get(key);\n    setSafeProperty(object, key, value);\n  }\n\n  return object;\n}\n/**\n * Returns `true` if the passed object appears to be a Map (i.e. duck typing).\n *\n * Methods looked for are `get`, `set`, `keys` and `has`.\n *\n * @param {Map | object} object\n * @returns\n */\n\nexport function isMap(object) {\n  // We can use the fast instanceof, or a slower duck typing check.\n  // The duck typing method needs to cover enough methods to not be confused with DenseMatrix.\n  if (!object) {\n    return false;\n  }\n\n  return object instanceof Map || object instanceof ObjectWrappingMap || typeof object.set === 'function' && typeof object.get === 'function' && typeof object.keys === 'function' && typeof object.has === 'function';\n}\n/**\n * Copies the contents of key-value pairs from each `objects` in to `map`.\n *\n * Object is `objects` can be a `Map` or object.\n *\n * This is the `Map` analog to `Object.assign`.\n */\n\nexport function assign(map) {\n  for (var _len = arguments.length, objects = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    objects[_key - 1] = arguments[_key];\n  }\n\n  for (var args of objects) {\n    if (!args) {\n      continue;\n    }\n\n    if (isMap(args)) {\n      for (var key of args.keys()) {\n        map.set(key, args.get(key));\n      }\n    } else if (isObject(args)) {\n      for (var _key2 of Object.keys(args)) {\n        map.set(_key2, args[_key2]);\n      }\n    }\n  }\n\n  return map;\n}"]},"metadata":{},"sourceType":"module"}